import { smsg } from "../comandos/configuraciones/simple.js"
import { format } from "util"
import { fileURLToPath } from "url"
import path, { join } from "path"
import fs, { unwatchFile, watchFile } from "fs"
import chalk from "chalk"
import fetch from "node-fetch"
import ws from "ws"

const isNumber = x => typeof x === "number" && !isNaN(x)
const delay = ms => isNumber(ms) && new Promise(resolve => setTimeout(function () {
  clearTimeout(this)
  resolve()
}, ms))

export async function handler(chatUpdate) {
  this.msgqueque = this.msgqueque || []
  this.uptime = this.uptime || Date.now()
  if (!chatUpdate) return
  this.pushMessage(chatUpdate.messages).catch(console.error)
  let m = chatUpdate.messages[chatUpdate.messages.length - 1]
  if (!m) return
  if (global.db.data == null) await global.loadDatabase()

  try {
    m = smsg(this, m) || m
    if (!m) return
    m.exp = 0

    // ----- USUARIO -----
    const user = global.db.data.users[m.sender] || {}
    if (!("name" in user)) user.name = m.name
    if (!("exp" in user) || !isNumber(user.exp)) user.exp = 0
    if (!("level" in user) || !isNumber(user.level)) user.level = 0
    if (!("health" in user) || !isNumber(user.health)) user.health = 100
    if (!("genre" in user)) user.genre = ""
    if (!("birth" in user)) user.birth = ""
    if (!("marry" in user)) user.marry = ""
    if (!("description" in user)) user.description = ""
    if (!("packstickers" in user)) user.packstickers = null
    if (!("premium" in user)) user.premium = false
    if (!("premiumTime" in user)) user.premiumTime = 0
    if (!("banned" in user)) user.banned = false
    if (!("bannedReason" in user)) user.bannedReason = ""
    if (!("commands" in user) || !isNumber(user.commands)) user.commands = 0
    if (!("afk" in user) || !isNumber(user.afk)) user.afk = -1
    if (!("afkReason" in user)) user.afkReason = ""
    if (!("warn" in user) || !isNumber(user.warn)) user.warn = 0
    global.db.data.users[m.sender] = user

    // ----- CHAT -----
    const chat = global.db.data.chats[m.chat] || {}
    if (!("isBanned" in chat)) chat.isBanned = false
    if (!("isMute" in chat)) chat.isMute = false
    if (!("welcome" in chat)) chat.welcome = false
    if (!("sWelcome" in chat)) chat.sWelcome = ""
    if (!("sBye" in chat)) chat.sBye = ""
    if (!("detect" in chat)) chat.detect = true
    if (!("primaryBot" in chat)) chat.primaryBot = null
    if (!("modoadmin" in chat)) chat.modoadmin = false
    if (!("antiLink" in chat)) chat.antiLink = true
    if (!("gacha" in chat)) chat.gacha = true
    global.db.data.chats[m.chat] = chat

    // ----- SETTINGS -----
    const settings = global.db.data.settings[this.user.jid] || {}
    if (!("self" in settings)) settings.self = false
    if (!("restrict" in settings)) settings.restrict = true
    if (!("jadibotmd" in settings)) settings.jadibotmd = true
    if (!("antiPrivate" in settings)) settings.antiPrivate = false
    if (!("gponly" in settings)) settings.gponly = false
    global.db.data.settings[this.user.jid] = settings

  } catch (e) {
    console.error(e)
  }

  if (typeof m.text !== "string") m.text = ""

  // Actualizar nombre del usuario
  try {
    const actual = user.name || ""
    const nuevo = m.pushName || await this.getName(m.sender)
    if (typeof nuevo === "string" && nuevo.trim() && nuevo !== actual) user.name = nuevo
  } catch (e) {}

  // ----- PERMISOS -----
  const isROwner = [...global.owner.map(v => v.replace(/[^0-9]/g, "") + "@s.whatsapp.net")].includes(m.sender)
  const isOwner = isROwner || m.fromMe
  const isPrems = isROwner || global.prems.map(v => v.replace(/[^0-9]/g, "") + "@s.whatsapp.net").includes(m.sender) || user.premium === true
  const isOwners = [this.user.jid, ...global.owner.map(v => v + "@s.whatsapp.net")].includes(m.sender)
  if (settings.self && !isOwners) return
  if (settings.gponly && !isOwners && !m.chat.endsWith('g.us') && !/code|p|ping|qr|estado|status|infobot|botinfo|report|reportar|invite|join|logout|suggest|help|menu/gim.test(m.text)) return

  if (opts["queque"] && m.text && !isPrems) {
    const queque = this.msgqueque, time = 1000 * 5
    const previousID = queque[queque.length - 1]
    queque.push(m.id || m.key.id)
    setInterval(async function () {
      if (queque.indexOf(previousID) === -1) clearInterval(this)
      await delay(time)
    }, time)
  }

  if (m.isBaileys) return
  m.exp += Math.ceil(Math.random() * 10)

  // ----- PLUGINS -----
  const ___dirname = path.join(path.dirname(fileURLToPath(import.meta.url)), "./comandos")
  for (const name in global.plugins) {
    const plugin = global.plugins[name]
    if (!plugin || plugin.disabled) continue
    const __filename = join(___dirname, name)
    if (typeof plugin.all === "function") {
      try { await plugin.all.call(this, m, { chatUpdate, __dirname: ___dirname, __filename, user, chat, settings }) }
      catch (err) { console.error(err) }
    }

    let strRegex = str => str.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&")
    const pluginPrefix = plugin.customPrefix || conn.prefix || global.prefix
    const match = (pluginPrefix instanceof RegExp ? [[pluginPrefix.exec(m.text), pluginPrefix]] : Array.isArray(pluginPrefix) ? pluginPrefix.map(prefix => { const regex = prefix instanceof RegExp ? prefix : new RegExp(strRegex(prefix)); return [regex.exec(m.text), regex] }) : [[new RegExp(strRegex(pluginPrefix)).exec(m.text), new RegExp(strRegex(pluginPrefix))]]).find(p => p[1])

    if (!match) continue
    const usedPrefix = (match[0] || "")[0]
    const noPrefix = m.text.replace(usedPrefix, "")
    let [command, ...args] = noPrefix.trim().split(" ").filter(v => v)
    args = args || []
    let _args = noPrefix.trim().split(" ").slice(1)
    let text = _args.join(" ")
    command = (command || "").toLowerCase()

    // ----- DFAlL -----
    const fail = plugin.fail || global.dfail
    if (plugin.rowner && !isROwner) { fail("rowner", m, this); continue }
    if (plugin.owner && !isOwner) { fail("owner", m, this); continue }
    if (plugin.mods && !isOwner) { fail("mods", m, this); continue }
    if (plugin.premium && !isPrems) { fail("premium", m, this); continue }
    if (plugin.group && !m.isGroup) { fail("group", m, this); continue }
    if (plugin.private && m.isGroup) { fail("private", m, this); continue }
    if (plugin.admin && m.isGroup && !user.admin) { fail("admin", m, this); continue }
    if (plugin.botAdmin && m.isGroup && !botGroup.admin) { fail("botAdmin", m, this); continue }
    if (plugin.restrict && !isOwner) { fail("restrict", m, this); continue }

    m.isCommand = true
    m.exp += plugin.exp ? parseInt(plugin.exp) : 10
    global.db.data.users[m.sender].commands = (global.db.data.users[m.sender].commands || 0) + 1
  }
}

// ----- DFAlL PERSONALIZADO -----
global.dfail = (type, m, conn) => {
  const msg = {
    rowner: `ùÑÑ◊Ñ„Ö§ùÖÑüå∏‚ÉûÕúÕ°·çù‚åíùÖÑ Esta funci√≥n solo la puede usar mi creador. ¬øQUIEN TE CREES?`,
    owner: `ùÑÑ◊Ñ„Ö§ùÖÑüå∏‚ÉûÕúÕ°·çù‚åíùÖÑ Esta funci√≥n solo la puede usar mi creador. ¬øQUIEN TE CREES?`,
    mods: `ùÑÑ◊Ñ„Ö§ùÖÑüå∏‚ÉûÕúÕ°·çù‚åíùÖÑ Esta funci√≥n solo la puede usar mi creador. ¬øQUIEN TE CREES?`,
    premium: `ùÑÑ◊Ñ„Ö§ùÖÑüçí‚Éû·çùÕ°Õú‚åíùÖÑ Estas funciones son premium. No puedes usarlo lol.`,
    group: `ùÑÑ◊Ñ„Ö§ùÖÑüå∑‚ÉûÕ°Õú·çù‚åíùÖÑ Usaste mal un comando o intentaste usar un comando siendo tan nub? üåù. Solo sirve en grupos.`,
    private: `ùÑÑ◊Ñ„Ö§ùÖÑü™∑‚Éû·çùÕ°Õú‚åíùÖÑ ERES TAN NUB QUE CREES PODER USAR ESTE COMANDO EN UN GRUPO. Solo funciona en chat privado.`,
    admin: `ùÑÑ◊Ñ„Ö§ùÖÑüçì‚Éû·çùÕ°Õú‚åíùÖÑ Esto lo puede usar un administrador. Que te crees..?`,
    botAdmin: `ùÑÑ◊Ñ„Ö§ùÖÑüíÆ‚Éû·çùÕ°Õú‚åíùÖÑ Este comando s√≥lo puede ser ejecutado si soy administradora del grupo.`,
    restrict: `ùÑÑ◊Ñ„Ö§ùÖÑü´ê‚Éû·çùÕ°Õú‚åíùÖÑ Este comando solo puede ser usado por mi Owner. ¬øQui√©n te crees?`
  }[type]
  if (msg) return conn.reply(m.chat, msg, m).then(_ => m.react('üõë'))
}

// ----- WATCH FILE -----
let file = global.__filename(import.meta.url, true)
watchFile(file, async () => {
  unwatchFile(file)
  console.log(chalk.magenta("Se actualiz√≥ 'handler.js'"))
})